package com.ardublock.core;

import java.util.Observable;
import java.util.Observer;

import com.ardublock.translator.Translator;
import com.ardublock.translator.block.exception.BlockException;
import com.ardublock.translator.block.exception.SocketNullException;
import com.ardublock.translator.block.exception.SubroutineNotDeclaredException;

import edu.mit.blocks.codeblocks.Block;
import edu.mit.blocks.renderable.RenderableBlock;
import edu.mit.blocks.workspace.MyBlock;
import edu.mit.blocks.workspace.Workspace;

public class SaveBlockObserver implements Observer{
	Workspace workspace;
	public SaveBlockObserver(Workspace workspace){
		this.workspace = workspace;
	}

	public void update(Observable oberservable, Object block) {
		
		if(block instanceof Block){
			//System.out.println("block name is "+ ((Block) block).getGenusName());
			Translator translator = new Translator(workspace);
			recursion((Block) block);

			//try {
			//	workspace.getBlockSave().writeToXML(/*(Block)block,*/new MyBlock(),/* translator.translateForSave(((Block) block).getBlockID()),*/workspace);
			//} catch (SocketNullException e) {
				// TODO Auto-generated catch block
			/*	e.printStackTrace();
			} catch (SubroutineNotDeclaredException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (BlockException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}*/
		}
	}

	//TODO: EXCLUDE THE CURRENT FUNCTION FROM THE RECURSION____> use accerelator method
	private void recursion(Block block) {
	//	System.out.println("block name is "+block.getGenusName()+"  and blockID is "+block.getBlockID());
		Long blockID = block.getBlockID();
		for(int i= 0; i<block.getNumSockets();i++){
			//if there is a block at the connector, then recurse
			if(!block.getSocketAt(i).getBlockID().equals(Block.NULL)){
				recursion(workspace.getEnv().getBlock(block.getSocketAt(i).getBlockID()));
			}
		}
		if(block.getAfterBlockID() != Block.NULL){
			recursion(workspace.getEnv().getBlock(block.getAfterBlockID()));
		}
		if(block.getGenusName().equals("function")&&block.getSocketAt(block.getNumSockets()-1).getKind().equals("cmd")){
			//System.out.println("block name that is there "+workspace.getEnv().getBlock(block.getSocketAt(0).getBlockID()).getBlockLabel());
			//THROW ERROR BECAUSE THIS IS NOT SUPPOSED TO BE ATTACHED TO THE BLOCK
		}else if(block.getGenusName().equals("function")&&!block.getSocketAt(block.getNumSockets()-1).getKind().equals("cmd")){
			String functionName = workspace.getEnv().getBlock(block.getSocketAt(0).getBlockID()).getBlockLabel();
			System.out.println("blockLabel/functionName LOOKING IS __________________"+functionName);
			Iterable<RenderableBlock> renderableBlocks =workspace.getRenderableBlocks();
			for (RenderableBlock renderableBlock:renderableBlocks)
			{
				System.out.println("hello");
				Block possibleBlock = renderableBlock.getBlock();
				//finds all block that is not connected to any prior blocks
				if (!possibleBlock.hasPlug() && (Block.NULL.equals(block.getBeforeBlockID())))
				{
					System.out.println(workspace.getEnv().getBlock(possibleBlock.getSocketAt(0).getBlockID()).getBlockLabel());
					if(possibleBlock.getGenusName().equals("function")){
					if(workspace.getEnv().getBlock(possibleBlock.getSocketAt(0).getBlockID()).getBlockLabel().equals(functionName)){
						System.out.println("FOUND ------------------>function name is "+functionName+" and bingo!");
					}
					}
				}
		}
		
	}
	}

}
